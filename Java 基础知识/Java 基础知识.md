# Java 基础

## 面向对象的特征有哪些方面？ 

- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程。
- 继承：继承是从已有类得到继承信息创建新类的过程。
- 封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
- 多态：允许不同子类型的对象对同一消息作出不同的响应。

## 访问修饰符public,private,protected,以及不写（默认）时的区别？ 

![1489928029 1](https://cloud.githubusercontent.com/assets/22606175/24081050/2e06c76e-0ce6-11e7-9439-3582c5b3ed04.jpg)

注意：protected 修饰的数据域和方法可被同包访问

## String 是最基本的数据类型吗？ 

Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型，剩下的都是引用类型。

## float f=3.4;是否正确？ 

3.4 是双精度数，3.4f 才是单精度数。Java 中默认小数为双精度数。

## short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗？ 

对于`short s1 = 1; s1 = s1 + 1;`，由于 1 是 int 类型，因此 `s1 + 1` 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。

对于`short s1 = 1; s1 += 1;`，可以正确编译，因为`s1 += 1;`相当于`s1 = (short)(s1 + 1);`其中有**隐含的强制类型转换**。

## int和Integer有什么区别？ 

Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 

## 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法

- 通常定义一个基本数据类型的变量、一个对象的引用、以及函数调用的现场保存都使用 JVM 中的栈空间
- 而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；
- 方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、即时编译（JIT）编译器编译后的代码等
- 程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在运行时常量池中，运行时常量池是方法区的一部分。
- 栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError ，而堆和常量池空间不足则会引发 OutOfMemoryError 。

`String str = new String("hello");`

上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。

## Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？ 

12；-11；四舍五入的原理是在参数上加0.5然后进行下取整。

## switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？ 

byte、short、char、int 和 String 类型可以。就是 long 型不可以。

## 用最有效率的方法计算2乘以8？ 

 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

## 构造器（constructor）是否可被重写（override）？ 

构造器不能被继承，因此不能被重写，但可以被重载。

## 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？ 

不对，如果两个对象 x 和 y 满足`x.equals(y) == true`，它们的哈希码（hash code）应当相同。

Java 对于 eqauls 方法和 hashCode 方法是这样规定的：

1. 如果两个对象相同（equals 方法返回 true），那么它们的hashCode值一定要相同
2. 如果两个对象的 hashCode 相同，它们并不一定相同

> 当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）

## String 和 StringBuilder、StringBuffer 的区别？ 

答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。

## 是否可以继承String类？ 

String 类是 final 类，不可以被继承。

## 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

- 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同）则视为重载；重载对返回类型没有特殊的要求
- 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，不能比父类被重写方法声明更多的异常（里氏代换原则）

## char 型变量中能不能存贮一个中文汉字？ 

char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode 。而一个 char 类型占2个字节。

## 抽象类（abstract class）和接口（interface）有什么异同？ 

相同点： 都不可实例化，但可以定义抽象类和接口类型的引用

不同点：

- 抽象类有构造器，允许有抽象方法和具体方法；接口没有构造器，且方法必须是抽象方法；
- 接口中成员全是 static public 类型
- 接口可以多继承

## * 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？ 

Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。

思考： 下面那些语句会有编译错误？
```
class Outer {

    class Inner {}

    public static void foo() { new Inner(); } // error

    public void bar() { new Inner(); }

    public static void main(String[] args) {  // error
        new Inner();
    }
}
```

## Java 中会存在内存泄漏吗，请简单描述。

理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生（比如当一个栈中出栈元素时，只是把栈的计数减一）。此外，Native 方法由于是用非 Java 语言写的，所以也可能导致内存泄露。

## * 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？ 

都不能。

抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。

本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。

synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。

## * 如何实现对象克隆？ 

有两种方式： 
  1). 实现 Cloneable 接口并重写 Object 类中的 clone() 方法
  2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆

> 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。

## GC是什么？为什么要有GC？ 

GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显式的垃圾回收调用。 

垃圾回收可以有效的防止内存泄露，有效使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。

> 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用“分代式垃圾收集”。这种方法会跟 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 
- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 
- 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 
- 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

## String s = new String("xyz");创建了几个字符串对象？ 

两个对象，一个是静态区的"xyz"，一个是用 new 创建在堆上的对象。

## 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 

接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。

## 一个".java"源文件中是否可以包含多个类（不是内部类）？有什么限制？ 

可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。

## Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？ 

可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。

## * 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 

一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

## Java 中的 final 关键字有哪些用法？ 

- 修饰类：表示该类不能被继承
- 修饰方法：表示方法不能被重写
- 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）

## * 指出下面程序的运行结果

```
class A {

    static {
        System.out.print("1");
    }

    public A() {
        System.out.print("2");
    }
}

class B extends A{

    static {
        System.out.print("a");
    }

    public B() {
        System.out.print("b");
    }
}

public class Hello {

    public static void main(String[] args) {
        A ab = new B();
        ab = new B();
    }

}
```

执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。

## 数据类型之间的转换

问： 

- 如何将字符串转换为基本数据类型？ 
- 如何将基本数据类型转换为字符串？ 

答： 

- 调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型； 
- 一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的 valueOf() 方法返回相应字符串

## Error和Exception有什么区别？ 

Error 表示系统级的错误和程序不必处理的异常，是恢复很困难的情况下的一种严重问题（比如内存溢出，不可能指望程序能处理这样的情况）；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题。

常见的几种异常如下：
 
- NullPointerException - **空指针引用异常**
- ClassCastException - **类型强制转换异常**
- IllegalArgumentException - 传递非法参数异常
- ArithmeticException - **算术运算异常**
- ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
- IndexOutOfBoundsException - **下标越界异常**
- NegativeArraySizeException - 创建一个大小为负数的数组错误异常
- UnsupportedOperationException - **不支持的操作异常**
- FileNotFoundException - **文件未找到异常**
- IOException - 输入输出异常
- NoSuchMethodException - 方法未找到异常
- ClassNotFoundException - 类定义未找到异常
- IllegalMonitorStateException - 当wait() 方法未在同步块中使用

> java.lang.UnsupportedOperationException 是指请求的方法不被支持的异常。在从 Arrays.asList() 转化过来的 List 的不支持 add() 和 remove() 方法，这是由于从 Arrays.asList() 返回的是返回 java.util.Arrays\$ArrayList ，而不是 ArrayList 。 Arrays\$ArrayList 和 ArrayList 都是继承 AbstractList ，add() 和 remove() 等方法在 AbstractList 中默认 throw UnsupportedOperationException 而不做任何操作。 ArrayList 重写这些方法对 List 进行操作，而 Arrays\$ArrayList 却没有重写 add() 和 remove() 等方法，所以对从 Arrays.asList() 转化过来的 List 进行 add() 和 remove() 会出现 UnsupportedOperationException 异常

## try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后? 

会执行，在方法返回调用者前执行。

> 注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值。如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，Java 中可以通过提升编译器的语法检查级别来产生警告或错误。

## Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？ 

Java 通过面向对象的方法进行异常处理，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象（该对象中包含有异常信息），调用这个对象的方法可以捕获到这个异常并可以对其进行处理。

Java 的异常处理是通过5个关键词来实现的：try、catch、throw、throws 和 finally 。

 - try 用于指定一块预防所有异常的程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；
 - catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；
 - throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；
 - finally 为确保一段代码不管发生什么异常状况都要被执行；
 - try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM 。

## 运行时异常与受检（必检）异常有何异同？

RuntimeException、Error 以及它们的子类都被称为免检异常（unchecked Exception）。所有其他异常都称为必检异常（checked Exception），意思是指编译器会强制程序员检查并处理它们。

异常表示程序运行过程中可能出现的非正常状态。运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。

## 阐述final、finally、finalize的区别 

- final：
	- 如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。
	- 将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。
	- 被声明为 final 的方法也同样只能使用，不能在子类中被重写。 
- finally：通常放在 try…catch… 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。 
- finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。

## List、Set、Map是否继承自Collection接口？ 

List、Set 是，Map 不是。Map是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。

## 阐述 ArrayList、Vector、LinkedList 的存储性能和特性

ArrayList 和 Vector 都是使用数组方式存储数据，数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。

LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

Vector 属于遗留容器，已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用。

## Collection 和 Collections 的区别？ 

Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。

## List、Map、Set 三个接口存取元素时，各有什么特点？ 

List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals() 方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。

## TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ 

TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo() 方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。

Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小。 

## Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 

sleep() 方法是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。

wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

> 注意：对象等待池和等锁池是两个不同的概念

总结如下：

- wait() 方法会释放锁，而 sleep() 方法不会释放锁。
- 进入 wait 状态的线程能够被 notify 和 notifyAll 唤醒，但是进入 sleeping 状态的线程只能到了规定的时间再自动苏醒。
- Java 中的 wait() 方法只能在同步代码块中调用，但是 sleep() 方法不需要。

> 补充：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。

## 线程的sleep()方法和yield()方法有什么区别？ 

- sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会
- 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态
- sleep() 方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常
- sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性

## 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池）中等待对象的锁。

## 请说出与线程同步以及线程调度相关的方法。 

- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁
- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常
- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关
- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态

> Java 5通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition() 方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。

## 编写多线程程序有几种实现方式？ 

Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现 Runnable 接口。两种方式都要通过重写 run() 方法来定义线程的行为。

推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。此外更重要的是，可以把线程逻辑从线程的执行中分离出来。

## 举例说明同步和异步

如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），那么这些数据就必须进行同步存取（如数据库操作中的排他锁）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。

## 什么是线程池（thread pool）？ 

在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是**池化资源**技术产生的原因。

线程池就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 提供 Executor 接口来执行线程池中的任务，提供 ExecutoeService 接口来管理和控制任务。

## 线程的基本状态以及状态之间的关系？ 

![enter image description here](http://img.blog.csdn.net/20150408002007838)

## Java中如何实现序列化，有什么意义？ 

序列化是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 

要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的。然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object) 方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。

## Interge的线程安全容器是？

[Java 原子操作 AtomicInteger 的用法](http://www.jianshu.com/p/509aca840f6d)

## 线程安全的集合对象

- ArrayList 线程不安全，Vector 线程安全；
- HashMap 线程不安全，HashTable 线程安全；
- StringBuilder 线程不安全，StringBuffer 线程安全。

[Java 集合的实现原理](http://wiki.jikexueyuan.com/project/java-collection/)

## 托管代码与非托管代码的区别

- 托管代码是一种中间语言，运行在 CLR（公共语言运行库）上；非托管代码被编译为机器码，运行在机器上。
- 托管代码独立于平台和语言，能更好的实现不同语言平台之间的兼容；非托管代码依赖于平台和语言。
- 托管代码可享受 CLR 提供的服务（如安全检测、垃圾回收等），不需要自己完成这些操作；非托管代码需要自己提供安全检测、垃圾回收等操作。

[托管代码与非托管代码](http://gauyanm.blog.51cto.com/629619/581107)