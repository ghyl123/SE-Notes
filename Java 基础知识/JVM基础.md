# JVM基础

 Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM 实现了 Java 最重要的特征：平台无关性。

原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM 屏蔽了与具体平台相关的信息，使 Java 语言编译程序只需要生成在 JVM 上运行的目标字节码（.class），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行，由此实现平台无关性。

![JVM模型](https://segmentfault.com/img/bVkZat)

JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区(runtime data area)

## 类加载器(classloader)

类加载器用于装载 .class 文件到 JVM 中，有两种装载 class 的方式 ：

- 隐式：运行过程中，碰到 new 方式生成对象时，隐式调用 classLoader 到 JVM
- 显式：通过 Class.forname() 动态加载

### 双亲委托机制

类的加载过程采用**双亲委托机制**，这种机制能更好的保证 Java 平台的安全。

该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间。

双亲委托机制的工作过程如下：

1. 当前 classLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。（每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，
等下次加载的时候就可以直接返回）
2. 当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader 。（当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回）

类加载器 classloader 是具有层次结构的，也就是父子关系。其中 Bootstrap 是所有类加载器的父亲。

![类加载器层次结构](https://segmentfault.com/img/bVk0W2)

使用双亲委托机制的目的在于：

1. 安全性考虑：为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String。
2. 避免重复加载：JVM 中区分不同类，不仅仅是根据类名。相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException。

## 执行引擎(execution engine)

执行引擎用于执行字节码或者本地方法。

## 运行时数据区域(JVM Runtime Area)

JVM 运行时数据区 (JVM Runtime Area) 是 JVM 在运行期间，其对 JVM 内存空间的划分和分配。JVM 在运行时将数据划分为了多个区域来存储。

程序员写的 Java 程序都被加载到运行时数据区域中，按不同类别存放在堆（Heap）、方法区（Method Area）、虚拟机栈（VM Stack）、程序计数器（PC）中。

![Java内存结构](http://img.blog.csdn.net/20140218172737265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hhb2ZhbndlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

- **程序计数器**：线程私有。当前线程所执行的字节码的指令计数器，存储每个线程下一步将执行的 JVM 指令。

- **JVM栈**：线程私有。与线程同时创建，生命周期与线程相同。每个方法被执行的时候都会同时创建一个**栈帧**（Stack Frame）用于存储局部变量、操作数栈等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

![JVM栈](https://segmentfault.com/img/bVmxl8)

- **Native 方法栈**：线程私有。类似于 JVM 栈，但虚拟机栈用于为虚拟机执行 java 方法，而本地方法栈则用于为虚拟机执行 native 方法。（native 方法是原生函数，是用 C/C++ 语言实现的，并且被编译成了 DLL，由 java 去调用）

- **Java 堆**：被所有线程共享的存储区域，在虚拟机启动时创建。它是 JVM 用于存储对象实例和数组的区域，Java 中所有通过 new 创建的对象的内存都在此分配。（这些对象被 GC 自动管理，无需也无法显式被销毁）
	- 内存分配方式：**指针碰撞**（用一个指针指向内存已用区和空闲区的分界点）和**空闲列表**（用一个列表记录哪些内存块可用）。
	- 指针碰撞的分配方式明显要优于空闲列表的方式，但是使用哪种方式取决于堆内存是否规整，而堆内存是否规整则由使用的垃圾收集算法决定。
	- 堆在 JVM 是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是 new 开销比较大的原因。
	- 鉴于上面的原因，Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为 TLAB。

- **方法区**：被所有线程共享的内存区域，在虚拟机启动时创建，它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。**JVM 用持久代（Permanet Generation）来存放方法区**。
	- 运行时常量池：方法区的一部分，存放的为类中固定的常量信息、方法和域的引用信息。

# GC

垃圾回收机制是由垃圾收集器 Garbage Collection（GC）来实现的，GC 是后台的守护进程。它是一个低优先级进程，但是可以根据内存的使用情况动态的调整它的优先级。因此，它在内存可用量低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。

程序运行期间，所有对象实例存储在运行时数据区域的 heap 中，当一个对象不再被引用（使用），它就需要被收回。在 GC 过程中，这些不再被使用的对象从 heap 中收回，这样就会有内存空间被循环利用。

由于 GC 要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了分代的方式进行对象的收集，以缩短 GC 对应用造成的暂停。

在垃圾回收器回收内存之前，还需要一些清理工作。
因为 GC 只能回收通过 new 申请的内存（在堆上），但是堆上的内存并不完全是通过 new 申请分配的。还有一些本地方法（一般是调用的 C 方法）。这部分特殊内存如果不手动释放，就会导致内存泄露，而 GC 是无法回收这部分内存的。
所以需要在 finalize 中用本地方法(native method)如 free 操作等，再使用 gc 方法。显式的 GC 方法是 system.gc() 。

## 找出需要回收的对象

- 引用计数法：给对象添加一个引用计数器，计数器的值代表着这个对象被引用的次数，当计数器的值为0的时候，就代表没有引用指向这个对象，所以就可以对它进行回收。但无法解决对象循环引用的问题。（即多个对象互相循环引用，但没有其他对象持有这些对象的引用，从而是一个孤立的系统）
- 可达性分析：从一些顶点开始，对有向图中的每个顶点进行可达性分析，就可以把不可达的对象找出来。这些起始对象被称为 GC Roots。可以作为 GC Roots 的对象有：栈区中引用的对象、 方法区中静态属性或常量引用的对象。

## 垃圾回收算法

找到需要回收的对象后，即可进行回收。JVM 中的 GC 是"自适应"的垃圾回收器，它会根据不同的环境和需要选择不同的处理方式。

### 标记-清除算法
通过可达性分析算法找到可以回收的对象后，对这些对象进行标记，代表它可以被回收。标记完成之后就统一回收所有被标记的对象。但是这种方式会产生大量的内存碎片，导致可用内存不规整，于是分配新的内存时就需要采用空闲列表的方法。如果没有找到足够大的空间，那么就要提前触发下一次垃圾收集。

### 标记-整理算法
标记的过程和标记-清除算法一样，但是标记完成之后，让所有存活的对象都向堆内存的一端移动，最后直接清除掉边界以外的内存。这样对内存进行回收之后，内存是规整的，于是可以使用指针碰撞的方式分配新的内存。

### 复制算法
标记-清除算法和标记-整理算法都使用先标记的方式，但当对象数量很多时，这种算法的效率并不高。

复制算法将可用内存分成两个部分，每次只使用其中的一部分，当其中一块用完时，就将仍然存活的对象复制到另外一块上，再把原来的那一块内存清理掉。这样回收的结果同样能得到规整的剩余空间，但是会浪费一部分内存。

可将新生代划分为三个部分，分别为Eden、Survivor from、Survivor to，大小比例为8：1：1。每次只使用 Eden 和其中的一块 Survivor，回收时将存活的对象复制到另一块 Survivor 中，这样就只有10%的内存被浪费，但是如果存活的对象总大小超过了 Survivor 的大小，那么就把多出的对象放入老年代中。

### 分代收集算法（结合以上三种算法）
把 Java堆分成新生代和老年代，新生代使用复制算法，老年代使用标记-清理或标记-整理算法。这样可以根据各个代自己的特点，选用合适的收集算法，提高内存收集的效率。在新生代中长期存活的对象会逐渐向老年代过渡，新生代中的对象每经历一次 GC，年龄就增加一岁，当年龄超过一定值时，就会被移动到旧生代。

## heap 的组成

由于 GC 需要消耗一些资源和时间的，Java 在对对象的生命周期特征进行分析后，采用了分代的方式来进行对象的收集，即按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短 GC 对应用造成的暂停。

heap 的组成有三区域/世代：(可以理解随着时间，对象实例不断变换 heap 中的等级)

- 新生代（Young Generation）
	- Eden Space：任何新进入运行时数据区域的实例都会存放在此
	- S0 Suvivor Space：存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0
	- S1 Survivor Space：存在时间更长的实例，就从S0 搬到了S1
- 旧生代（Old Generation/tenured）：存在时间更长的对象，多次 GC 没被清除，就从 S1 搬到了 tenured
- 持久代：存放运行时数据区的方法区

![分区](https://segmentfault.com/img/bVkZav)

Java 对新生代和旧生代使用不同的 GC 算法。新生代做“复制收集”，旧生代做“标记压缩收集”。

> PS：搬运工作都由 GC 完成。GC 负责在 heap 中搬运实例，以及收回存储空间。

## \*对象引用类型

JVM 中将对象的引用分为了四种类型，不同的对象引用类型会造成 GC 采用不同的方法进行回收： 

1. 强引用：默认情况下，对象采用的均为强引用。（GC 不会回收）
2. 软引用：软引用是 Java 中提供的一种比较适合于缓存场景的应用。（只有在内存不够用的情况下才会被GC）
3. 弱引用：在GC时一定会被GC回收 
4. 虚引用：在GC时一定会被GC回收